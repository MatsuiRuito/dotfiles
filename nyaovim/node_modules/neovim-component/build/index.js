(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],2:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
}).call(this,require('_process'))
},{"_process":6}],3:[function(require,module,exports){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 */

module.exports.Dispatcher = require('./lib/Dispatcher');

},{"./lib/Dispatcher":4}],4:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule Dispatcher
 * 
 * @preventMunge
 */

'use strict';

exports.__esModule = true;

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var invariant = require('fbjs/lib/invariant');

var _prefix = 'ID_';

/**
 * Dispatcher is used to broadcast payloads to registered callbacks. This is
 * different from generic pub-sub systems in two ways:
 *
 *   1) Callbacks are not subscribed to particular events. Every payload is
 *      dispatched to every registered callback.
 *   2) Callbacks can be deferred in whole or part until other callbacks have
 *      been executed.
 *
 * For example, consider this hypothetical flight destination form, which
 * selects a default city when a country is selected:
 *
 *   var flightDispatcher = new Dispatcher();
 *
 *   // Keeps track of which country is selected
 *   var CountryStore = {country: null};
 *
 *   // Keeps track of which city is selected
 *   var CityStore = {city: null};
 *
 *   // Keeps track of the base flight price of the selected city
 *   var FlightPriceStore = {price: null}
 *
 * When a user changes the selected city, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'city-update',
 *     selectedCity: 'paris'
 *   });
 *
 * This payload is digested by `CityStore`:
 *
 *   flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'city-update') {
 *       CityStore.city = payload.selectedCity;
 *     }
 *   });
 *
 * When the user selects a country, we dispatch the payload:
 *
 *   flightDispatcher.dispatch({
 *     actionType: 'country-update',
 *     selectedCountry: 'australia'
 *   });
 *
 * This payload is digested by both stores:
 *
 *   CountryStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       CountryStore.country = payload.selectedCountry;
 *     }
 *   });
 *
 * When the callback to update `CountryStore` is registered, we save a reference
 * to the returned token. Using this token with `waitFor()`, we can guarantee
 * that `CountryStore` is updated before the callback that updates `CityStore`
 * needs to query its data.
 *
 *   CityStore.dispatchToken = flightDispatcher.register(function(payload) {
 *     if (payload.actionType === 'country-update') {
 *       // `CountryStore.country` may not be updated.
 *       flightDispatcher.waitFor([CountryStore.dispatchToken]);
 *       // `CountryStore.country` is now guaranteed to be updated.
 *
 *       // Select the default city for the new country
 *       CityStore.city = getDefaultCityForCountry(CountryStore.country);
 *     }
 *   });
 *
 * The usage of `waitFor()` can be chained, for example:
 *
 *   FlightPriceStore.dispatchToken =
 *     flightDispatcher.register(function(payload) {
 *       switch (payload.actionType) {
 *         case 'country-update':
 *         case 'city-update':
 *           flightDispatcher.waitFor([CityStore.dispatchToken]);
 *           FlightPriceStore.price =
 *             getFlightPriceStore(CountryStore.country, CityStore.city);
 *           break;
 *     }
 *   });
 *
 * The `country-update` payload will be guaranteed to invoke the stores'
 * registered callbacks in order: `CountryStore`, `CityStore`, then
 * `FlightPriceStore`.
 */

var Dispatcher = (function () {
  function Dispatcher() {
    _classCallCheck(this, Dispatcher);

    this._callbacks = {};
    this._isDispatching = false;
    this._isHandled = {};
    this._isPending = {};
    this._lastID = 1;
  }

  /**
   * Registers a callback to be invoked with every dispatched payload. Returns
   * a token that can be used with `waitFor()`.
   */

  Dispatcher.prototype.register = function register(callback) {
    var id = _prefix + this._lastID++;
    this._callbacks[id] = callback;
    return id;
  };

  /**
   * Removes a callback based on its token.
   */

  Dispatcher.prototype.unregister = function unregister(id) {
    !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.unregister(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
    delete this._callbacks[id];
  };

  /**
   * Waits for the callbacks specified to be invoked before continuing execution
   * of the current callback. This method should only be used by a callback in
   * response to a dispatched payload.
   */

  Dispatcher.prototype.waitFor = function waitFor(ids) {
    !this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Must be invoked while dispatching.') : invariant(false) : undefined;
    for (var ii = 0; ii < ids.length; ii++) {
      var id = ids[ii];
      if (this._isPending[id]) {
        !this._isHandled[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): Circular dependency detected while ' + 'waiting for `%s`.', id) : invariant(false) : undefined;
        continue;
      }
      !this._callbacks[id] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatcher.waitFor(...): `%s` does not map to a registered callback.', id) : invariant(false) : undefined;
      this._invokeCallback(id);
    }
  };

  /**
   * Dispatches a payload to all registered callbacks.
   */

  Dispatcher.prototype.dispatch = function dispatch(payload) {
    !!this._isDispatching ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch.') : invariant(false) : undefined;
    this._startDispatching(payload);
    try {
      for (var id in this._callbacks) {
        if (this._isPending[id]) {
          continue;
        }
        this._invokeCallback(id);
      }
    } finally {
      this._stopDispatching();
    }
  };

  /**
   * Is this Dispatcher currently dispatching.
   */

  Dispatcher.prototype.isDispatching = function isDispatching() {
    return this._isDispatching;
  };

  /**
   * Call the callback stored with the given id. Also do some internal
   * bookkeeping.
   *
   * @internal
   */

  Dispatcher.prototype._invokeCallback = function _invokeCallback(id) {
    this._isPending[id] = true;
    this._callbacks[id](this._pendingPayload);
    this._isHandled[id] = true;
  };

  /**
   * Set up bookkeeping needed when dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._startDispatching = function _startDispatching(payload) {
    for (var id in this._callbacks) {
      this._isPending[id] = false;
      this._isHandled[id] = false;
    }
    this._pendingPayload = payload;
    this._isDispatching = true;
  };

  /**
   * Clear bookkeeping used for dispatching.
   *
   * @internal
   */

  Dispatcher.prototype._stopDispatching = function _stopDispatching() {
    delete this._pendingPayload;
    this._isDispatching = false;
  };

  return Dispatcher;
})();

module.exports = Dispatcher;
}).call(this,require('_process'))
},{"_process":6,"fbjs/lib/invariant":2}],5:[function(require,module,exports){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (typeof define === 'function' && define.amd) {
        define(definition);
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";
    var noop = function() {};
    var undefinedType = "undefined";

    function realMethod(methodName) {
        if (typeof console === undefinedType) {
            return false; // We can't build a real method without a console to log to
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // these private functions always need `this` to be set properly

    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }
    }

    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public API
       *
       */

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Package-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    return defaultLogger;
}));

},{}],6:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var neovim_1 = require("./neovim");
Polymer({
    is: 'neovim-editor',
    properties: {
        width: Number,
        height: Number,
        fontSize: {
            type: Number,
            value: 12,
        },
        font: {
            type: String,
            value: 'monospace',
        },
        lineHeight: {
            type: Number,
            value: 1.3,
        },
        nvimCmd: {
            type: String,
            value: 'nvim',
        },
        argv: {
            type: Array,
            value: function () { return []; },
        },
        disableAltKey: {
            type: Boolean,
            value: false,
        },
        disableMetaKey: {
            type: Boolean,
            value: false,
        },
        cursorDrawDelay: {
            type: Number,
            value: 10,
        },
        noBlinkCursor: {
            type: Boolean,
            value: false,
        },
        windowTitle: {
            type: String,
            value: 'Neovim',
        },
        editor: Object,
        onProcessAttached: Object,
        onQuit: Object,
        onError: Object,
        resizeHandler: Object,
    },
    ready: function () {
        this.editor = new neovim_1.default(this.nvimCmd, this.argv, this.font, this.fontSize, this.lineHeight, this.disableAltKey, this.disableMetaKey, this.cursorDrawDelay, !this.noBlinkCursor, this.windowTitle);
        this.resizeHandler = null;
        if (this.onError) {
            this.editor.on('error', this.onError);
        }
        if (this.onQuit) {
            this.editor.on('quit', this.onQuit);
        }
        if (this.onProcessAttached) {
            this.editor.on('process-attached', this.onProcessAttached);
        }
    },
    attached: function () {
        var _this = this;
        var canvas = document.querySelector('.neovim-canvas');
        var width = this.width || canvas.parentElement.offsetWidth;
        var height = this.height || canvas.parentElement.offsetHeight;
        this.editor.attachCanvas(width, height, canvas);
        this.resize_listener = window.addEventListener('resize', function () {
            if (_this.resizeHandler !== null) {
                clearTimeout(_this.resizeHandler);
            }
            _this.resizeHandler = setTimeout(function () {
                _this.editor.screen.checkShouldResize();
                _this.resizeHandler = null;
            }, 100);
        });
    },
    detached: function () {
        this.editor.emit('detach');
        if (this.resize_listener) {
            window.removeEventListener('resize', this.resize_listener);
        }
    },
    attributeChanged: function (name, type) {
        this.editor.emit('change-attribute', name, type);
    },
});

},{"./neovim":9}],8:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.NODE_ENV = (function () {
    try {
        return global.require('electron').remote.process.env.NODE_ENV;
    }
    catch (e) {
        return 'production';
    }
})();
var LogLevel = 'info';
if (exports.NODE_ENV === 'production') {
    LogLevel = 'warn';
}
else if (exports.NODE_ENV === 'debug') {
    LogLevel = 'debug';
}
var log = require("loglevel");
log.setLevel(LogLevel);
exports.default = log;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"loglevel":5}],9:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var process_1 = require("./neovim/process");
var screen_1 = require("./neovim/screen");
var store_1 = require("./neovim/store");
var actions_1 = require("./neovim/actions");
var Neovim = (function (_super) {
    __extends(Neovim, _super);
    function Neovim(command, argv, font, font_size, line_height, disable_alt_key, disable_meta_key, draw_delay, blink_cursor, window_title) {
        var _this = _super.call(this) || this;
        _this.store = new store_1.default();
        _this.store.dispatcher.dispatch(actions_1.updateLineHeight(line_height));
        _this.store.dispatcher.dispatch(actions_1.updateFontFace(font));
        _this.store.dispatcher.dispatch(actions_1.updateFontPx(font_size));
        if (disable_alt_key) {
            _this.store.dispatcher.dispatch(actions_1.disableAltKey(true));
        }
        if (disable_meta_key) {
            _this.store.dispatcher.dispatch(actions_1.disableMetaKey(true));
        }
        _this.store.dispatcher.dispatch(actions_1.changeCursorDrawDelay(draw_delay));
        if (blink_cursor) {
            _this.store.dispatcher.dispatch(actions_1.startBlinkCursor());
        }
        _this.store.dispatcher.dispatch(actions_1.setTitle(window_title));
        _this.process = new process_1.default(_this.store, command, argv);
        return _this;
    }
    Neovim.prototype.attachCanvas = function (width, height, canvas) {
        var _this = this;
        this.store.dispatcher.dispatch(actions_1.updateScreenSize(width, height));
        this.screen = new screen_1.default(this.store, canvas);
        var _a = this.store.size, lines = _a.lines, cols = _a.cols;
        this.process
            .attach(lines, cols)
            .then(function () {
            _this.process.client.on('disconnect', function () { return _this.emit('quit'); });
            _this.emit('process-attached');
        }).catch(function (err) { return _this.emit('error', err); });
    };
    Neovim.prototype.quit = function () {
        this.process.finalize();
    };
    Neovim.prototype.getClient = function () {
        return this.process.client;
    };
    Neovim.prototype.focus = function () {
        this.screen.focus();
    };
    Neovim.prototype.setArgv = function (argv) {
        if (!this.process.started) {
            throw new Error("Process is not attached yet.  Use 'process-attached' event to ensure to specify arguments.");
        }
        return this.process.client.command('args ' + argv.join(' '));
    };
    return Neovim;
}(events_1.EventEmitter));
exports.default = Neovim;

},{"./neovim/actions":10,"./neovim/process":13,"./neovim/screen":16,"./neovim/store":17,"events":1}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Kind;
(function (Kind) {
    Kind[Kind["Bell"] = 0] = "Bell";
    Kind[Kind["BusyStart"] = 1] = "BusyStart";
    Kind[Kind["BusyStop"] = 2] = "BusyStop";
    Kind[Kind["ChangeCursorDrawDelay"] = 3] = "ChangeCursorDrawDelay";
    Kind[Kind["ClearAll"] = 4] = "ClearAll";
    Kind[Kind["ClearEOL"] = 5] = "ClearEOL";
    Kind[Kind["Cursor"] = 6] = "Cursor";
    Kind[Kind["DisableMouse"] = 7] = "DisableMouse";
    Kind[Kind["DisableAltKey"] = 8] = "DisableAltKey";
    Kind[Kind["DisableMetaKey"] = 9] = "DisableMetaKey";
    Kind[Kind["DragEnd"] = 10] = "DragEnd";
    Kind[Kind["DragStart"] = 11] = "DragStart";
    Kind[Kind["DragUpdate"] = 12] = "DragUpdate";
    Kind[Kind["EnableMouse"] = 13] = "EnableMouse";
    Kind[Kind["Highlight"] = 14] = "Highlight";
    Kind[Kind["Input"] = 15] = "Input";
    Kind[Kind["Mode"] = 16] = "Mode";
    Kind[Kind["PutText"] = 17] = "PutText";
    Kind[Kind["Resize"] = 18] = "Resize";
    Kind[Kind["ScrollScreen"] = 19] = "ScrollScreen";
    Kind[Kind["SetIcon"] = 20] = "SetIcon";
    Kind[Kind["SetScrollRegion"] = 21] = "SetScrollRegion";
    Kind[Kind["SetTitle"] = 22] = "SetTitle";
    Kind[Kind["StartBlinkCursor"] = 23] = "StartBlinkCursor";
    Kind[Kind["StopBlinkCursor"] = 24] = "StopBlinkCursor";
    Kind[Kind["UpdateBG"] = 25] = "UpdateBG";
    Kind[Kind["UpdateFG"] = 26] = "UpdateFG";
    Kind[Kind["UpdateSP"] = 27] = "UpdateSP";
    Kind[Kind["UpdateFontFace"] = 28] = "UpdateFontFace";
    Kind[Kind["UpdateFontPx"] = 29] = "UpdateFontPx";
    Kind[Kind["UpdateFontSize"] = 30] = "UpdateFontSize";
    Kind[Kind["UpdateLineHeight"] = 31] = "UpdateLineHeight";
    Kind[Kind["UpdateScreenBounds"] = 32] = "UpdateScreenBounds";
    Kind[Kind["UpdateScreenSize"] = 33] = "UpdateScreenSize";
    Kind[Kind["WheelScroll"] = 34] = "WheelScroll";
    Kind[Kind["FocusChanged"] = 35] = "FocusChanged";
})(Kind = exports.Kind || (exports.Kind = {}));
function putText(text) {
    return {
        type: Kind.PutText,
        text: text,
    };
}
exports.putText = putText;
function cursor(line, col) {
    return {
        type: Kind.Cursor,
        line: line, col: col,
    };
}
exports.cursor = cursor;
function highlight(highlight) {
    return {
        type: Kind.Highlight,
        highlight: highlight,
    };
}
exports.highlight = highlight;
function clearAll() {
    return {
        type: Kind.ClearAll,
    };
}
exports.clearAll = clearAll;
function clearEndOfLine() {
    return {
        type: Kind.ClearEOL,
    };
}
exports.clearEndOfLine = clearEndOfLine;
function resize(lines, cols) {
    return {
        type: Kind.Resize,
        lines: lines, cols: cols,
    };
}
exports.resize = resize;
function updateForeground(color) {
    return {
        type: Kind.UpdateFG,
        color: color,
    };
}
exports.updateForeground = updateForeground;
function updateBackground(color) {
    return {
        type: Kind.UpdateBG,
        color: color,
    };
}
exports.updateBackground = updateBackground;
function updateSpecialColor(color) {
    return {
        type: Kind.UpdateSP,
        color: color,
    };
}
exports.updateSpecialColor = updateSpecialColor;
function changeMode(mode) {
    return {
        type: Kind.Mode,
        mode: mode,
    };
}
exports.changeMode = changeMode;
function startBusy() {
    return {
        type: Kind.BusyStart,
    };
}
exports.startBusy = startBusy;
function stopBusy() {
    return {
        type: Kind.BusyStop,
    };
}
exports.stopBusy = stopBusy;
function updateFontSize(draw_width, draw_height, width, height) {
    return {
        type: Kind.UpdateFontSize,
        draw_width: draw_width, draw_height: draw_height,
        width: width, height: height,
    };
}
exports.updateFontSize = updateFontSize;
function inputToNeovim(input) {
    return {
        type: Kind.Input,
        input: input,
    };
}
exports.inputToNeovim = inputToNeovim;
function updateFontPx(font_px) {
    return {
        type: Kind.UpdateFontPx,
        font_px: font_px,
    };
}
exports.updateFontPx = updateFontPx;
function updateFontFace(font_face) {
    return {
        type: Kind.UpdateFontFace,
        font_face: font_face,
    };
}
exports.updateFontFace = updateFontFace;
function updateScreenSize(width, height) {
    return {
        type: Kind.UpdateScreenSize,
        width: width, height: height,
    };
}
exports.updateScreenSize = updateScreenSize;
function updateScreenBounds(lines, cols) {
    return {
        type: Kind.UpdateScreenBounds,
        lines: lines, cols: cols,
    };
}
exports.updateScreenBounds = updateScreenBounds;
function enableMouse() {
    return {
        type: Kind.EnableMouse,
    };
}
exports.enableMouse = enableMouse;
function disableMouse() {
    return {
        type: Kind.DisableMouse,
    };
}
exports.disableMouse = disableMouse;
function dragStart(event) {
    return {
        type: Kind.DragStart,
        event: event,
    };
}
exports.dragStart = dragStart;
function dragUpdate(event) {
    return {
        type: Kind.DragUpdate,
        event: event,
    };
}
exports.dragUpdate = dragUpdate;
function dragEnd(event) {
    return {
        type: Kind.DragEnd,
        event: event,
    };
}
exports.dragEnd = dragEnd;
function bell(visual) {
    return {
        type: Kind.Bell,
        visual: visual,
    };
}
exports.bell = bell;
function setTitle(title) {
    return {
        type: Kind.SetTitle,
        title: title,
    };
}
exports.setTitle = setTitle;
function setIcon(icon_path) {
    return {
        type: Kind.SetIcon,
        icon_path: icon_path,
    };
}
exports.setIcon = setIcon;
function wheelScroll(event) {
    return {
        type: Kind.WheelScroll,
        event: event,
    };
}
exports.wheelScroll = wheelScroll;
function scrollScreen(cols) {
    return {
        type: Kind.ScrollScreen,
        cols: cols,
    };
}
exports.scrollScreen = scrollScreen;
function setScrollRegion(region) {
    return {
        type: Kind.SetScrollRegion,
        region: region,
    };
}
exports.setScrollRegion = setScrollRegion;
function notifyFocusChanged(focused) {
    return {
        type: Kind.FocusChanged,
        focused: focused,
    };
}
exports.notifyFocusChanged = notifyFocusChanged;
function updateLineHeight(line_height) {
    return {
        type: Kind.UpdateLineHeight,
        line_height: line_height,
    };
}
exports.updateLineHeight = updateLineHeight;
function disableAltKey(disabled) {
    return {
        type: Kind.DisableAltKey,
        disabled: disabled,
    };
}
exports.disableAltKey = disableAltKey;
function disableMetaKey(disabled) {
    return {
        type: Kind.DisableMetaKey,
        disabled: disabled,
    };
}
exports.disableMetaKey = disableMetaKey;
function changeCursorDrawDelay(delay) {
    return {
        type: Kind.ChangeCursorDrawDelay,
        delay: delay,
    };
}
exports.changeCursorDrawDelay = changeCursorDrawDelay;
function startBlinkCursor() {
    return {
        type: Kind.StartBlinkCursor,
    };
}
exports.startBlinkCursor = startBlinkCursor;
function stopBlinkCursor() {
    return {
        type: Kind.StopBlinkCursor,
    };
}
exports.stopBlinkCursor = stopBlinkCursor;

},{}],11:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var log_1 = require("../log");
var actions_1 = require("./actions");
function invertColor(image) {
    var d = image.data;
    for (var i = 0; i < d.length; i += 4) {
        d[i] = 255 - d[i];
        d[i + 1] = 255 - d[i + 1];
        d[i + 2] = 255 - d[i + 2];
    }
    return image;
}
var CursorBlinkTimer = (function (_super) {
    __extends(CursorBlinkTimer, _super);
    function CursorBlinkTimer(interval) {
        var _this = _super.call(this) || this;
        _this.interval = interval;
        _this.token = null;
        _this.enabled = false;
        _this.shown = true;
        _this.callback = _this._callback.bind(_this);
        return _this;
    }
    CursorBlinkTimer.prototype.start = function () {
        if (this.enabled) {
            return;
        }
        this.shown = true;
        this.token = window.setTimeout(this.callback, this.interval);
        this.enabled = true;
    };
    CursorBlinkTimer.prototype.stop = function () {
        if (!this.enabled) {
            return;
        }
        if (this.token !== null) {
            window.clearTimeout(this.token);
            this.token = null;
        }
        this.enabled = false;
    };
    CursorBlinkTimer.prototype.reset = function () {
        if (this.enabled) {
            this.stop();
            this.start();
        }
    };
    CursorBlinkTimer.prototype._callback = function () {
        this.shown = !this.shown;
        this.emit('tick', this.shown);
        this.token = window.setTimeout(this.callback, this.interval);
    };
    return CursorBlinkTimer;
}(events_1.EventEmitter));
var NeovimCursor = (function () {
    function NeovimCursor(store, screen_ctx) {
        var _this = this;
        this.store = store;
        this.screen_ctx = screen_ctx;
        this.delay_timer = null;
        this.blink_timer = new CursorBlinkTimer(this.store.cursor_blink_interval);
        this.element = document.querySelector('.neovim-cursor');
        this.element.style.top = '0px';
        this.element.style.left = '0px';
        this.ctx = this.element.getContext('2d', { alpha: false });
        this.updateSize();
        this.blink_timer.on('tick', function (shown) {
            if (shown) {
                _this.redraw();
            }
            else {
                _this.dismiss();
            }
        });
        if (this.store.blink_cursor) {
            this.blink_timer.start();
        }
        this.element.addEventListener('mouseup', function (e) {
            _this.store.dispatcher.dispatch(actions_1.dragEnd(e));
        });
        this.element.addEventListener('click', function (e) {
            e.preventDefault();
            var i = document.querySelector('.neovim-input');
            if (i) {
                i.focus();
            }
        });
        this.store.on('cursor', this.updateCursorPos.bind(this));
        this.store.on('update-fg', function () { return _this.redraw(); });
        this.store.on('font-size-changed', this.updateSize.bind(this));
        this.store.on('blink-cursor-started', function () { return _this.blink_timer.start(); });
        this.store.on('blink-cursor-stopped', function () { return _this.blink_timer.stop(); });
        this.store.on('busy', function () {
            if (_this.store.busy) {
                _this.dismiss();
                _this.blink_timer.stop();
            }
            else {
                _this.redraw();
                if (_this.store.blink_cursor) {
                    _this.blink_timer.start();
                }
            }
        });
        this.store.on('focus-changed', function () { return _this.updateCursorBlinking(_this.store.focused); });
        this.store.on('mode', function () { return _this.updateCursorBlinking(_this.store.mode !== 'insert'); });
    }
    NeovimCursor.prototype.updateSize = function () {
        var f = this.store.font_attr;
        this.element.style.width = f.width + 'px';
        this.element.style.height = f.height + 'px';
        this.element.width = f.draw_width;
        this.element.height = f.draw_height;
        this.redraw();
    };
    NeovimCursor.prototype.dismiss = function () {
        this.ctx.clearRect(0, 0, this.element.width, this.element.height);
    };
    NeovimCursor.prototype.redraw = function () {
        if (this.store.cursor_draw_delay <= 0) {
            this.redrawImpl();
            return;
        }
        if (this.delay_timer !== null) {
            clearTimeout(this.delay_timer);
        }
        else {
            this.ctx.clearRect(0, 0, this.element.width, this.element.height);
        }
        this.delay_timer = setTimeout(this.redrawImpl.bind(this), this.store.cursor_draw_delay);
    };
    NeovimCursor.prototype.updateCursorPos = function () {
        var _a = this.store.cursor, line = _a.line, col = _a.col;
        var _b = this.store.font_attr, width = _b.width, height = _b.height;
        var x = col * width;
        var y = line * height;
        this.element.style.left = x + 'px';
        this.element.style.top = y + 'px';
        log_1.default.debug("Cursor is moved to (" + x + ", " + y + ")");
        this.redraw();
        this.blink_timer.reset();
    };
    NeovimCursor.prototype.redrawImpl = function () {
        this.delay_timer = null;
        var cursor_width = this.store.mode.endsWith('insert') ? (window.devicePixelRatio || 1) : this.store.font_attr.draw_width;
        var cursor_height = this.store.font_attr.draw_height;
        var x = this.store.cursor.col * this.store.font_attr.draw_width;
        var y = this.store.cursor.line * this.store.font_attr.draw_height;
        var captured = this.screen_ctx.getImageData(x, y, cursor_width, cursor_height);
        this.ctx.putImageData(invertColor(captured), 0, 0);
    };
    NeovimCursor.prototype.updateCursorBlinking = function (should_blink) {
        if (should_blink) {
            if (this.store.blink_cursor) {
                this.blink_timer.start();
            }
        }
        else {
            this.blink_timer.stop();
            if (!this.blink_timer.shown) {
                this.redraw();
            }
        }
    };
    return NeovimCursor;
}());
exports.default = NeovimCursor;

},{"../log":8,"./actions":10,"events":1}],12:[function(require,module,exports){
(function (global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var actions_1 = require("./actions");
var log_1 = require("../log");
var OnDarwin = global.process.platform === 'darwin';
var IsAlpha = /^[a-zA-Z]$/;
var NeovimInput = (function () {
    function NeovimInput(store) {
        this.store = store;
        this.ime_running = false;
        this.element = document.querySelector('.neovim-input');
        this.element.addEventListener('compositionstart', this.startComposition.bind(this));
        this.element.addEventListener('compositionend', this.endComposition.bind(this));
        this.element.addEventListener('keydown', this.onInputNonText.bind(this));
        this.element.addEventListener('input', this.onInputText.bind(this));
        this.element.addEventListener('blur', this.onBlur.bind(this));
        this.element.addEventListener('focus', this.onFocus.bind(this));
        this.store.on('cursor', this.updateElementPos.bind(this));
        this.focus();
    }
    NeovimInput.shouldIgnoreOnKeydown = function (event) {
        var ctrlKey = event.ctrlKey, shiftKey = event.shiftKey, altKey = event.altKey, keyCode = event.keyCode, metaKey = event.metaKey;
        return !ctrlKey && !altKey && !metaKey ||
            shiftKey && keyCode === 16 ||
            ctrlKey && keyCode === 17 ||
            altKey && keyCode === 18 ||
            metaKey && keyCode === 91;
    };
    NeovimInput.getVimSpecialCharFromKeyCode = function (key_code, shift) {
        switch (key_code) {
            case 0: return 'Nul';
            case 8: return 'BS';
            case 9: return 'Tab';
            case 10: return 'NL';
            case 13: return 'CR';
            case 33: return 'PageUp';
            case 34: return 'PageDown';
            case 27: return 'Esc';
            case 32: return 'Space';
            case 35: return 'End';
            case 36: return 'Home';
            case 37: return 'Left';
            case 38: return 'Up';
            case 39: return 'Right';
            case 40: return 'Down';
            case 45: return 'Insert';
            case 46: return 'Del';
            case 47: return 'Help';
            case 92: return 'Bslash';
            case 112: return 'F1';
            case 113: return 'F2';
            case 114: return 'F3';
            case 115: return 'F4';
            case 116: return 'F5';
            case 117: return 'F6';
            case 118: return 'F7';
            case 119: return 'F8';
            case 120: return 'F9';
            case 121: return 'F10';
            case 122: return 'F11';
            case 123: return 'F12';
            case 124: return 'Bar';
            case 127: return 'Del';
            case 188: return shift ? 'LT' : null;
            default: return null;
        }
    };
    NeovimInput.getVimSpecialCharFromKey = function (event) {
        var key = event.key;
        if (key.length === 1) {
            switch (key) {
                case '<': return event.ctrlKey || event.altKey ? 'LT' : null;
                case ' ': return 'Space';
                case '\0': return 'Nul';
                default: return null;
            }
        }
        if (key[0] === 'F') {
            return /^F\d+/.test(key) ? key : null;
        }
        var ctrl = event.ctrlKey;
        var key_code = event.keyCode;
        switch (key) {
            case 'Escape': {
                if (ctrl && key_code !== 27) {
                    return '[';
                }
                else {
                    return 'Esc';
                }
            }
            case 'Backspace': {
                if (ctrl && key_code === 72) {
                    return 'h';
                }
                else {
                    return 'BS';
                }
            }
            case 'Tab': {
                if (ctrl && key_code === 73) {
                    return 'i';
                }
                else {
                    return 'Tab';
                }
            }
            case 'Enter': {
                if (ctrl && key_code === 77) {
                    return 'm';
                }
                else if (ctrl && key_code === 67) {
                    return 'c';
                }
                else {
                    return 'CR';
                }
            }
            case 'PageUp': return 'PageUp';
            case 'PageDown': return 'PageDown';
            case 'End': return 'End';
            case 'Home': return 'Home';
            case 'ArrowLeft': return 'Left';
            case 'ArrowUp': return 'Up';
            case 'ArrowRight': return 'Right';
            case 'ArrowDown': return 'Down';
            case 'Insert': return 'Insert';
            case 'Delete': return 'Del';
            case 'Help': return 'Help';
            case 'Unidentified': return null;
            default: return null;
        }
    };
    NeovimInput.getVimSpecialCharInput = function (event) {
        var should_fallback = (event.key === undefined) ||
            (event.key === '\0' && event.keyCode !== 0);
        var special_char = should_fallback ?
            NeovimInput.getVimSpecialCharFromKeyCode(event.keyCode, event.shiftKey) :
            NeovimInput.getVimSpecialCharFromKey(event);
        if (!special_char) {
            return null;
        }
        var vim_input = '<';
        if (event.ctrlKey) {
            vim_input += 'C-';
        }
        if (event.metaKey) {
            vim_input += 'D-';
        }
        if (event.altKey) {
            vim_input += 'A-';
        }
        if (event.shiftKey && special_char !== 'LT') {
            vim_input += 'S-';
        }
        vim_input += special_char + '>';
        return vim_input;
    };
    NeovimInput.replaceKeyToAvoidCtrlShiftSpecial = function (ctrl, shift, key) {
        if (!ctrl || shift) {
            return key;
        }
        switch (key) {
            case '6': return '^';
            case '-': return '_';
            case '2': return '@';
            default: return key;
        }
    };
    NeovimInput.getVimInputFromKeyCode = function (event) {
        var modifiers = '';
        if (event.ctrlKey) {
            modifiers += 'C-';
        }
        if (event.metaKey) {
            modifiers += 'D-';
        }
        if (event.altKey) {
            modifiers += 'A-';
        }
        if (event.shiftKey) {
            modifiers += 'S-';
        }
        var vim_input = NeovimInput.replaceKeyToAvoidCtrlShiftSpecial(event.ctrlKey, event.shiftKey, String.fromCharCode(event.keyCode).toLowerCase());
        if (modifiers !== '') {
            vim_input = "<" + modifiers + vim_input + ">";
        }
        return vim_input;
    };
    NeovimInput.prototype.startComposition = function (_) {
        log_1.default.debug('start composition');
        this.ime_running = true;
    };
    NeovimInput.prototype.endComposition = function (event) {
        log_1.default.debug('end composition');
        this.inputToNeovim(event.data, event);
        this.ime_running = false;
    };
    NeovimInput.prototype.focus = function () {
        this.element.focus();
    };
    NeovimInput.prototype.onFocus = function () {
        this.store.dispatcher.dispatch(actions_1.notifyFocusChanged(true));
        this.store.dispatcher.dispatch(actions_1.inputToNeovim('<FocusGained>'));
    };
    NeovimInput.prototype.onBlur = function (e) {
        e.preventDefault();
        this.store.dispatcher.dispatch(actions_1.notifyFocusChanged(false));
        this.store.dispatcher.dispatch(actions_1.inputToNeovim('<FocusLost>'));
    };
    NeovimInput.prototype.onInputNonText = function (event) {
        log_1.default.debug('Keydown event:', event);
        if (this.ime_running) {
            log_1.default.debug('IME is running.  Input canceled.');
            return;
        }
        var special_sequence = NeovimInput.getVimSpecialCharInput(event);
        if (special_sequence) {
            this.inputToNeovim(special_sequence, event);
            return;
        }
        if (NeovimInput.shouldIgnoreOnKeydown(event)) {
            return;
        }
        var should_osx_workaround = OnDarwin && event.altKey && !event.ctrlKey && this.store.mode === 'normal';
        if (this.store.alt_key_disabled && event.altKey) {
            Object.defineProperty(event, 'altKey', { value: false });
        }
        if (this.store.meta_key_disabled && event.metaKey) {
            return;
        }
        if (should_osx_workaround) {
            this.inputToNeovim(NeovimInput.getVimInputFromKeyCode(event), event);
            return;
        }
        if (event.key) {
            if (event.key.length === 1) {
                var input = '<';
                if (event.ctrlKey) {
                    input += 'C-';
                }
                if (event.metaKey) {
                    input += 'D-';
                }
                if (event.altKey) {
                    input += 'A-';
                }
                if (event.shiftKey && IsAlpha.test(event.key)) {
                    input += 'S-';
                }
                if (input === '<') {
                    this.inputToNeovim(event.key, event);
                }
                else {
                    var key = NeovimInput.replaceKeyToAvoidCtrlShiftSpecial(event.ctrlKey, event.shiftKey, event.key);
                    this.inputToNeovim(input + key + '>', event);
                }
            }
            else {
                log_1.default.warn("Invalid key input on 'keydown': ", event.key);
            }
        }
        else {
            this.inputToNeovim(NeovimInput.getVimInputFromKeyCode(event), event);
        }
    };
    NeovimInput.prototype.inputToNeovim = function (input, event) {
        this.store.dispatcher.dispatch(actions_1.inputToNeovim(input));
        log_1.default.debug('Input to neovim:', JSON.stringify(input));
        event.preventDefault();
        event.stopPropagation();
        var t = event.target;
        if (t.value) {
            t.value = '';
        }
    };
    NeovimInput.prototype.onInputText = function (event) {
        log_1.default.debug('Input event:', event);
        if (this.ime_running) {
            log_1.default.debug('IME is running.  Input canceled.');
            return;
        }
        var t = event.target;
        if (t.value === '') {
            log_1.default.warn('onInputText: Empty');
            return;
        }
        var input = t.value !== '<' ? t.value : '<LT>';
        this.inputToNeovim(input, event);
    };
    NeovimInput.prototype.updateElementPos = function () {
        var _a = this.store.cursor, line = _a.line, col = _a.col;
        var _b = this.store.font_attr, width = _b.width, height = _b.height;
        var x = col * width;
        var y = line * height;
        this.element.style.left = x + 'px';
        this.element.style.top = y + 'px';
    };
    return NeovimInput;
}());
exports.default = NeovimInput;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../log":8,"./actions":10}],13:[function(require,module,exports){
(function (process,global){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var child_process = global.require('child_process');
var attach = global.require('promised-neovim-client').attach;
var Action = require("./actions");
var log_1 = require("../log");
var NeovimProcess = (function () {
    function NeovimProcess(store, command, argv) {
        this.store = store;
        this.command = command;
        this.argv = argv;
        this.started = false;
        this.argv.unshift('--embed');
    }
    NeovimProcess.prototype.attach = function (lines, columns) {
        var _this = this;
        var err = null;
        this.client = null;
        this.neovim_process
            = child_process.spawn(this.command, this.argv, { stdio: ['pipe', 'pipe', process.stderr] });
        this.neovim_process.on('error', function (e) { err = e; });
        if (err || this.neovim_process.pid === undefined) {
            return Promise.reject(err || new Error('Failed to spawn process: ' + this.command));
        }
        return attach(this.neovim_process.stdin, this.neovim_process.stdout)
            .then(function (nvim) {
            _this.client = nvim;
            nvim.on('request', _this.onRequested.bind(_this));
            nvim.on('notification', _this.onNotified.bind(_this));
            nvim.on('disconnect', _this.onDisconnected.bind(_this));
            nvim.uiAttach(columns, lines, true, true);
            _this.started = true;
            log_1.default.info("nvim attached: " + _this.neovim_process.pid + " " + lines + "x" + columns + " " + JSON.stringify(_this.argv));
            _this.store.on('input', function (i) { return nvim.input(i); });
            _this.store.on('update-screen-bounds', function () { return nvim.uiTryResize(_this.store.size.cols, _this.store.size.lines); });
            _this.client.command('doautocmd <nomodeline> GUIEnter');
        });
    };
    NeovimProcess.prototype.onRequested = function (method, args, response) {
        log_1.default.info('requested: ', method, args, response);
    };
    NeovimProcess.prototype.onNotified = function (method, args) {
        if (method === 'redraw') {
            this.redraw(args);
        }
        else {
            log_1.default.debug('Unknown method', method, args);
        }
    };
    NeovimProcess.prototype.onDisconnected = function () {
        log_1.default.info('disconnected: ' + this.neovim_process.pid);
        this.started = false;
    };
    NeovimProcess.prototype.finalize = function () {
        var _this = this;
        return this.client.uiDetach().then(function () {
            _this.client.quit();
            _this.started = false;
        });
    };
    NeovimProcess.prototype.redraw = function (events) {
        var d = this.store.dispatcher;
        for (var _i = 0, events_1 = events; _i < events_1.length; _i++) {
            var e = events_1[_i];
            var name_1 = e[0];
            var args = e[1];
            switch (name_1) {
                case 'put':
                    e.shift();
                    if (e.length !== 0) {
                        d.dispatch(Action.putText(e));
                    }
                    break;
                case 'cursor_goto':
                    d.dispatch(Action.cursor(args[0], args[1]));
                    break;
                case 'highlight_set':
                    e.shift();
                    var highlights = [].concat.apply([], e);
                    highlights.unshift({});
                    var merged_highlight = Object.assign.apply(Object, highlights);
                    d.dispatch(Action.highlight(merged_highlight));
                    break;
                case 'clear':
                    d.dispatch(Action.clearAll());
                    break;
                case 'eol_clear':
                    d.dispatch(Action.clearEndOfLine());
                    break;
                case 'scroll':
                    d.dispatch(Action.scrollScreen(args[0]));
                    break;
                case 'set_scroll_region':
                    d.dispatch(Action.setScrollRegion({
                        top: args[0],
                        bottom: args[1],
                        left: args[2],
                        right: args[3],
                    }));
                    break;
                case 'resize':
                    d.dispatch(Action.resize(args[1], args[0]));
                    break;
                case 'update_fg':
                    d.dispatch(Action.updateForeground(args[0]));
                    break;
                case 'update_bg':
                    d.dispatch(Action.updateBackground(args[0]));
                    break;
                case 'update_sp':
                    d.dispatch(Action.updateSpecialColor(args[0]));
                    break;
                case 'mode_change':
                    d.dispatch(Action.changeMode(args[0]));
                    break;
                case 'busy_start':
                    d.dispatch(Action.startBusy());
                    break;
                case 'busy_stop':
                    d.dispatch(Action.stopBusy());
                    break;
                case 'mouse_on':
                    d.dispatch(Action.enableMouse());
                    break;
                case 'mouse_off':
                    d.dispatch(Action.disableMouse());
                    break;
                case 'bell':
                    d.dispatch(Action.bell(false));
                    break;
                case 'visual_bell':
                    d.dispatch(Action.bell(true));
                    break;
                case 'set_title':
                    d.dispatch(Action.setTitle(args[0]));
                    break;
                case 'set_icon':
                    d.dispatch(Action.setIcon(args[0]));
                    break;
                default:
                    log_1.default.warn('Unhandled event: ' + name_1, args);
                    break;
            }
        }
    };
    return NeovimProcess;
}());
exports.default = NeovimProcess;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../log":8,"./actions":10,"_process":6}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = require("../log");
var MouseButtonKind = ['Left', 'Middle', 'Right'];
var ScreenDrag = (function () {
    function ScreenDrag(store) {
        this.store = store;
        this.line = 0;
        this.col = 0;
    }
    ScreenDrag.buildInputOf = function (e, type, line, col) {
        var seq = '<';
        if (e.ctrlKey) {
            seq += 'C-';
        }
        if (e.altKey) {
            seq += 'A-';
        }
        if (e.shiftKey) {
            seq += 'S-';
        }
        seq += MouseButtonKind[e.button] + type + '>';
        seq += "<" + col + "," + line + ">";
        return seq;
    };
    ScreenDrag.prototype.start = function (down_event) {
        down_event.preventDefault();
        _a = this.getPos(down_event), this.line = _a[0], this.col = _a[1];
        log_1.default.info('Drag start', down_event, this.line, this.col);
        var input = ScreenDrag.buildInputOf(down_event, 'Mouse', this.line, this.col);
        log_1.default.debug('Mouse input: ' + input);
        return input;
        var _a;
    };
    ScreenDrag.prototype.drag = function (move_event) {
        var _a = this.getPos(move_event), line = _a[0], col = _a[1];
        if (line === this.line && col === this.col) {
            return null;
        }
        move_event.preventDefault();
        log_1.default.debug('Drag continue', move_event, line, col);
        var input = ScreenDrag.buildInputOf(move_event, 'Drag', line, col);
        this.line = line;
        this.col = col;
        log_1.default.debug('Mouse input: ' + input);
        return input;
    };
    ScreenDrag.prototype.end = function (up_event) {
        up_event.preventDefault();
        _a = this.getPos(up_event), this.line = _a[0], this.col = _a[1];
        log_1.default.info('Drag end', up_event, this.line, this.col);
        var input = ScreenDrag.buildInputOf(up_event, 'Release', this.line, this.col);
        log_1.default.info('Mouse input: ' + input);
        return input;
        var _a;
    };
    ScreenDrag.prototype.getPos = function (e) {
        return [
            Math.floor(e.clientY / this.store.font_attr.height),
            Math.floor(e.clientX / this.store.font_attr.width),
        ];
    };
    return ScreenDrag;
}());
exports.default = ScreenDrag;

},{"../log":8}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var log_1 = require("../log");
var ScreenWheel = (function () {
    function ScreenWheel(store) {
        this.store = store;
        this.reset();
    }
    ScreenWheel.prototype.handleEvent = function (e) {
        if ((this.shift === undefined && this.ctrl === undefined) ||
            (this.shift !== e.shiftKey || this.ctrl !== e.ctrlKey)) {
            this.reset(e.shiftKey, e.ctrlKey);
        }
        this.x += e.deltaX;
        this.y += e.deltaY;
        var scroll_x = Math.round(this.x / this.store.font_attr.draw_width / 6);
        var scroll_y = Math.round(this.y / this.store.font_attr.draw_height / 3);
        if (scroll_x === 0 && scroll_y === 0) {
            return '';
        }
        var col = Math.floor(e.offsetX / this.store.font_attr.width);
        var line = Math.floor(e.offsetY / this.store.font_attr.height);
        var input = this.getInput(scroll_x, scroll_y, line, col);
        log_1.default.debug("Scroll (" + scroll_x + ", " + scroll_y + ") at (" + line + ", " + col + "): " + input);
        this.reset();
        return input;
    };
    ScreenWheel.prototype.reset = function (shift, ctrl) {
        this.x = 0;
        this.y = 0;
        this.shift = shift;
        this.ctrl = ctrl;
    };
    ScreenWheel.prototype.getInput = function (scroll_x, scroll_y, line, col) {
        var pos = "<" + col + "," + line + ">";
        var modifier = '<';
        if (this.ctrl) {
            modifier += 'C-';
        }
        if (this.shift) {
            modifier += 'S-';
        }
        var seq = '';
        var y_dir = scroll_y > 0 ? 'Down' : 'Up';
        for (var _ = 0; _ < Math.abs(scroll_y); ++_) {
            seq += modifier + "ScrollWheel" + y_dir + ">" + pos;
        }
        var x_dir = scroll_x > 0 ? 'Left' : 'Right';
        for (var _ = 0; _ < Math.abs(scroll_x); ++_) {
            seq += modifier + "ScrollWheel" + x_dir + ">" + pos;
        }
        return seq;
    };
    return ScreenWheel;
}());
exports.default = ScreenWheel;

},{"../log":8}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var A = require("./actions");
var cursor_1 = require("./cursor");
var input_1 = require("./input");
var log_1 = require("../log");
var NeovimScreen = (function () {
    function NeovimScreen(store, canvas) {
        var _this = this;
        this.store = store;
        this.canvas = canvas;
        this.ctx = this.canvas.getContext('2d', { alpha: false });
        this.store.on('put', this.drawText.bind(this));
        this.store.on('clear-all', this.clearAll.bind(this));
        this.store.on('clear-eol', this.clearEol.bind(this));
        this.store.on('update-bg', this.clearAll.bind(this));
        this.store.on('screen-scrolled', this.scroll.bind(this));
        this.store.on('line-height-changed', function () { return _this.changeFontSize(_this.store.font_attr.specified_px); });
        this.changeFontSize(this.store.font_attr.specified_px);
        canvas.addEventListener('click', this.focus.bind(this));
        canvas.addEventListener('mousedown', this.mouseDown.bind(this));
        canvas.addEventListener('mouseup', this.mouseUp.bind(this));
        canvas.addEventListener('mousemove', this.mouseMove.bind(this));
        canvas.addEventListener('wheel', this.wheel.bind(this));
        this.cursor = new cursor_1.default(this.store, this.ctx);
        this.input = new input_1.default(this.store);
    }
    NeovimScreen.prototype.wheel = function (e) {
        this.store.dispatcher.dispatch(A.wheelScroll(e));
    };
    NeovimScreen.prototype.mouseDown = function (e) {
        this.store.dispatcher.dispatch(A.dragStart(e));
    };
    NeovimScreen.prototype.mouseUp = function (e) {
        this.store.dispatcher.dispatch(A.dragEnd(e));
    };
    NeovimScreen.prototype.mouseMove = function (e) {
        if (e.buttons !== 0) {
            this.store.dispatcher.dispatch(A.dragUpdate(e));
        }
    };
    NeovimScreen.prototype.resizeWithPixels = function (width_px, height_px) {
        var h = height_px * (window.devicePixelRatio || 1);
        var w = width_px * (window.devicePixelRatio || 1);
        this.resizeImpl(Math.floor(h / this.store.font_attr.draw_height), Math.floor(w / this.store.font_attr.draw_width), w, h);
    };
    NeovimScreen.prototype.resize = function (lines, cols) {
        this.resizeImpl(lines, cols, this.store.font_attr.draw_width * cols, this.store.font_attr.draw_height * lines);
    };
    NeovimScreen.prototype.changeFontSize = function (specified_px) {
        var drawn_px = specified_px * (window.devicePixelRatio || 1);
        this.ctx.font = drawn_px + 'px ' + this.store.font_attr.face;
        var font_width = this.ctx.measureText('m').width;
        var font_height = Math.ceil(this.store.line_height === 1.2 ?
            font_width * 2 :
            drawn_px * this.store.line_height);
        this.store.dispatcher.dispatch(A.updateFontPx(specified_px));
        this.store.dispatcher.dispatch(A.updateFontSize(font_width, font_height, font_width / (window.devicePixelRatio || 1), font_height / (window.devicePixelRatio)));
        var _a = this.store.size, width = _a.width, height = _a.height;
        this.resizeWithPixels(width, height);
    };
    NeovimScreen.prototype.changeLineHeight = function (new_value) {
        this.store.dispatcher.dispatch(A.updateLineHeight(new_value));
    };
    NeovimScreen.prototype.scroll = function (cols_delta) {
        if (cols_delta > 0) {
            this.scrollUp(cols_delta);
        }
        else if (cols_delta < 0) {
            this.scrollDown(-cols_delta);
        }
    };
    NeovimScreen.prototype.focus = function () {
        this.input.focus();
    };
    NeovimScreen.prototype.clearAll = function () {
        this.ctx.fillStyle = this.store.bg_color;
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    };
    NeovimScreen.prototype.clearEol = function () {
        var _a = this.store.cursor, line = _a.line, col = _a.col;
        var font_width = this.store.font_attr.draw_width;
        var clear_length = this.store.size.cols * font_width - col * font_width;
        log_1.default.debug("Clear until EOL: " + line + ":" + col + " length=" + clear_length);
        this.drawBlock(line, col, 1, clear_length, this.store.bg_color);
    };
    NeovimScreen.prototype.convertPositionToLocation = function (line, col) {
        var _a = this.store.font_attr, width = _a.width, height = _a.height;
        return {
            x: col * width,
            y: line * height,
        };
    };
    NeovimScreen.prototype.convertLocationToPosition = function (x, y) {
        var _a = this.store.font_attr, width = _a.width, height = _a.height;
        return {
            line: Math.floor(y * height),
            col: Math.floor(x * width),
        };
    };
    NeovimScreen.prototype.checkShouldResize = function () {
        var p = this.canvas.parentElement;
        var cw = p.clientWidth;
        var ch = p.clientHeight;
        var w = this.canvas.width;
        var h = this.canvas.height;
        if (cw * (window.devicePixelRatio || 1) !== w ||
            ch * (window.devicePixelRatio || 1) !== h) {
            this.resizeWithPixels(cw, ch);
        }
    };
    NeovimScreen.prototype.drawChars = function (x, y, chars, width) {
        var includes_half_only = true;
        for (var _i = 0, chars_1 = chars; _i < chars_1.length; _i++) {
            var c = chars_1[_i];
            if (!c[0]) {
                includes_half_only = false;
                break;
            }
        }
        if (includes_half_only) {
            var text = chars.map(function (c) { return (c[0] || ''); }).join('');
            this.ctx.fillText(text, x, y);
            return;
        }
        for (var _a = 0, chars_2 = chars; _a < chars_2.length; _a++) {
            var char = chars_2[_a];
            if (!char[0] || char[0] === ' ') {
                x += width;
                continue;
            }
            this.ctx.fillText(char.join(''), x, y);
            x += width;
        }
    };
    NeovimScreen.prototype.drawText = function (chars) {
        var _a = this.store.cursor, line = _a.line, col = _a.col;
        var _b = this.store.font_attr, fg = _b.fg, bg = _b.bg, sp = _b.sp, draw_width = _b.draw_width, draw_height = _b.draw_height, face = _b.face, specified_px = _b.specified_px, bold = _b.bold, italic = _b.italic, underline = _b.underline, undercurl = _b.undercurl;
        this.drawBlock(line, col, 1, chars.length, bg);
        var font_size = specified_px * (window.devicePixelRatio || 1);
        var attrs = '';
        if (bold) {
            attrs += 'bold ';
        }
        if (italic) {
            attrs += 'italic ';
        }
        this.ctx.font = attrs + font_size + 'px ' + face;
        this.ctx.textBaseline = 'top';
        this.ctx.fillStyle = fg;
        var margin = font_size * (this.store.line_height - 1.2) / 2;
        var y = Math.floor(line * draw_height + margin);
        var x = col * draw_width;
        this.drawChars(x, y, chars, draw_width);
        if (undercurl) {
            this.ctx.strokeStyle = sp || this.store.sp_color || fg;
            this.ctx.lineWidth = 1 * (window.devicePixelRatio || 1);
            this.ctx.setLineDash([draw_width / 3, draw_width / 3]);
            this.ctx.beginPath();
            var curl_y = y + draw_height - 3 * (window.devicePixelRatio || 1);
            this.ctx.moveTo(x, curl_y);
            this.ctx.lineTo(x + draw_width * chars.length, curl_y);
            this.ctx.stroke();
        }
        else if (underline) {
            this.ctx.strokeStyle = fg;
            this.ctx.lineWidth = 1 * (window.devicePixelRatio || 1);
            this.ctx.setLineDash([]);
            this.ctx.beginPath();
            var underline_y = y + draw_height - 3 * (window.devicePixelRatio || 1);
            this.ctx.moveTo(x, underline_y);
            this.ctx.lineTo(x + draw_width * chars.length, underline_y);
            this.ctx.stroke();
        }
        log_1.default.debug("drawText(): (" + x + ", " + y + ")", chars.length, this.store.cursor);
    };
    NeovimScreen.prototype.drawBlock = function (line, col, height, width, color) {
        var _a = this.store.font_attr, draw_width = _a.draw_width, draw_height = _a.draw_height;
        this.ctx.fillStyle = color;
        this.ctx.fillRect(Math.floor(col * draw_width), line * draw_height, Math.ceil(width * draw_width), height * draw_height);
    };
    NeovimScreen.prototype.slideVertical = function (top, height, dst_top) {
        var _a = this.store.scroll_region, left = _a.left, right = _a.right;
        var _b = this.store.font_attr, draw_width = _b.draw_width, draw_height = _b.draw_height;
        var captured = this.ctx.getImageData(left * draw_width, top * draw_height, (right - left + 1) * draw_width, height * draw_height);
        this.ctx.putImageData(captured, left * draw_width, dst_top * draw_height);
    };
    NeovimScreen.prototype.scrollUp = function (cols_up) {
        var _a = this.store.scroll_region, top = _a.top, bottom = _a.bottom, left = _a.left, right = _a.right;
        this.slideVertical(top + cols_up, bottom - (top + cols_up) + 1, top);
        this.drawBlock(bottom - cols_up + 1, left, cols_up, right - left + 1, this.store.bg_color);
        log_1.default.debug('Scroll up: ' + cols_up, this.store.scroll_region);
    };
    NeovimScreen.prototype.scrollDown = function (cols_down) {
        var _a = this.store.scroll_region, top = _a.top, bottom = _a.bottom, left = _a.left, right = _a.right;
        this.slideVertical(top, bottom - (top + cols_down) + 1, top + cols_down);
        this.drawBlock(top, left, cols_down, right - left + 1, this.store.bg_color);
        log_1.default.debug('Scroll down: ' + cols_down, this.store.scroll_region);
    };
    NeovimScreen.prototype.resizeImpl = function (lines, cols, width, height) {
        if (width !== this.canvas.width) {
            this.canvas.width = width;
            this.canvas.style.width = (width / (window.devicePixelRatio || 1)) + 'px';
        }
        if (height !== this.canvas.height) {
            this.canvas.height = height;
            this.canvas.style.height = (height / (window.devicePixelRatio || 1)) + 'px';
        }
        this.store.dispatcher.dispatch(A.updateScreenSize(width, height));
        this.store.dispatcher.dispatch(A.updateScreenBounds(lines, cols));
    };
    return NeovimScreen;
}());
exports.default = NeovimScreen;

},{"../log":8,"./actions":10,"./cursor":11,"./input":12}],17:[function(require,module,exports){
"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var actions_1 = require("./actions");
var log_1 = require("../log");
var screen_drag_1 = require("./screen-drag");
var screen_wheel_1 = require("./screen-wheel");
var flux_1 = require("flux");
function colorString(new_color, fallback) {
    if (typeof new_color !== 'number' || new_color < 0) {
        return fallback;
    }
    return '#' + [16, 8, 0].map(function (shift) {
        var mask = 0xff << shift;
        var hex = ((new_color & mask) >> shift).toString(16);
        return hex.length < 2 ? ('0' + hex) : hex;
    }).join('');
}
var NeovimStore = (function (_super) {
    __extends(NeovimStore, _super);
    function NeovimStore() {
        var _this = _super.call(this) || this;
        _this.dispatcher = new flux_1.Dispatcher();
        _this.size = {
            lines: 0,
            cols: 0,
            width: 0,
            height: 0,
        };
        _this.font_attr = {
            fg: 'white',
            bg: 'black',
            sp: null,
            bold: false,
            italic: false,
            underline: false,
            undercurl: false,
            draw_width: 1,
            draw_height: 1,
            width: 1,
            height: 1,
            specified_px: 1,
            face: 'monospace',
        };
        _this.cursor = {
            line: 0,
            col: 0,
        };
        _this.mode = 'normal';
        _this.busy = false;
        _this.mouse_enabled = true;
        _this.dragging = null;
        _this.title = '';
        _this.icon_path = '';
        _this.wheel_scrolling = new screen_wheel_1.default(_this);
        _this.scroll_region = {
            left: 0,
            right: 0,
            top: 0,
            bottom: 0,
        };
        _this.focused = true;
        _this.line_height = 1.2;
        _this.alt_key_disabled = false;
        _this.meta_key_disabled = false;
        _this.cursor_draw_delay = 10;
        _this.blink_cursor = false;
        _this.cursor_blink_interval = 1000;
        _this.dispatch_token = _this.dispatcher.register(_this.receiveAction.bind(_this));
        return _this;
    }
    NeovimStore.prototype.receiveAction = function (action) {
        switch (action.type) {
            case actions_1.Kind.Input: {
                this.emit('input', action.input);
                break;
            }
            case actions_1.Kind.PutText: {
                this.emit('put', action.text);
                this.cursor.col = this.cursor.col + action.text.length;
                this.emit('cursor');
                break;
            }
            case actions_1.Kind.Cursor: {
                this.cursor = {
                    line: action.line,
                    col: action.col,
                };
                this.emit('cursor');
                break;
            }
            case actions_1.Kind.Highlight: {
                var hl = action.highlight;
                this.font_attr.bold = hl.bold;
                this.font_attr.italic = hl.italic;
                this.font_attr.underline = hl.underline;
                this.font_attr.undercurl = hl.undercurl;
                if (hl.reverse === true) {
                    this.font_attr.fg = colorString(hl.background, this.bg_color);
                    this.font_attr.bg = colorString(hl.foreground, this.fg_color);
                }
                else {
                    this.font_attr.fg = colorString(hl.foreground, this.fg_color);
                    this.font_attr.bg = colorString(hl.background, this.bg_color);
                }
                this.font_attr.sp = colorString(hl.special, this.sp_color || this.fg_color);
                log_1.default.debug('Highlight is updated: ', this.font_attr);
                break;
            }
            case actions_1.Kind.FocusChanged: {
                this.focused = action.focused;
                this.emit('focus-changed');
                log_1.default.debug('Focus changed: ', this.focused);
                break;
            }
            case actions_1.Kind.ClearEOL: {
                this.emit('clear-eol');
                break;
            }
            case actions_1.Kind.ClearAll: {
                this.emit('clear-all');
                this.cursor = {
                    line: 0,
                    col: 0,
                };
                this.emit('cursor');
                break;
            }
            case actions_1.Kind.ScrollScreen: {
                this.emit('screen-scrolled', action.cols);
                break;
            }
            case actions_1.Kind.SetScrollRegion: {
                this.scroll_region = action.region;
                log_1.default.debug('Region is set: ', this.scroll_region);
                this.emit('scroll-region-updated');
                break;
            }
            case actions_1.Kind.Resize: {
                if (this.resize(action.lines, action.cols)) {
                    this.emit('resize');
                }
                break;
            }
            case actions_1.Kind.UpdateFG: {
                this.fg_color = colorString(action.color, this.font_attr.fg);
                this.emit('update-fg');
                log_1.default.debug('Foreground color is updated: ', this.fg_color);
                break;
            }
            case actions_1.Kind.UpdateBG: {
                this.bg_color = colorString(action.color, this.font_attr.bg);
                this.emit('update-bg');
                log_1.default.debug('Background color is updated: ', this.bg_color);
                break;
            }
            case actions_1.Kind.UpdateSP: {
                this.sp_color = colorString(action.color, this.fg_color);
                this.emit('update-sp-color');
                log_1.default.debug('Special color is updated: ', this.sp_color);
                break;
            }
            case actions_1.Kind.Mode: {
                this.mode = action.mode;
                this.emit('mode', this.mode);
                break;
            }
            case actions_1.Kind.BusyStart: {
                this.busy = true;
                this.emit('busy');
                break;
            }
            case actions_1.Kind.BusyStop: {
                this.busy = false;
                this.emit('busy');
                break;
            }
            case actions_1.Kind.UpdateFontSize: {
                this.font_attr.draw_width = action.draw_width;
                this.font_attr.draw_height = action.draw_height;
                this.font_attr.width = action.width;
                this.font_attr.height = action.height;
                log_1.default.debug('Actual font size is updated: ', action.width, action.height);
                this.emit('font-size-changed');
                break;
            }
            case actions_1.Kind.UpdateFontPx: {
                this.font_attr.specified_px = action.font_px;
                this.emit('font-px-specified');
                break;
            }
            case actions_1.Kind.UpdateFontFace: {
                this.font_attr.face = action.font_face;
                this.emit('font-face-specified');
                break;
            }
            case actions_1.Kind.UpdateScreenSize: {
                if (this.size.width === action.width
                    && this.size.height === action.height) {
                    break;
                }
                this.size.width = action.width;
                this.size.height = action.height;
                this.emit('update-screen-size');
                log_1.default.debug('Screen size is updated: ', action.width, action.height);
                break;
            }
            case actions_1.Kind.UpdateScreenBounds: {
                if (this.resize(action.lines, action.cols)) {
                    this.emit('update-screen-bounds');
                }
                break;
            }
            case actions_1.Kind.EnableMouse: {
                if (!this.mouse_enabled) {
                    this.mouse_enabled = true;
                    this.emit('mouse-enabled');
                    log_1.default.info('Mouse enabled.');
                }
                break;
            }
            case actions_1.Kind.DisableMouse: {
                if (this.mouse_enabled) {
                    this.mouse_enabled = false;
                    this.emit('mouse-disabled');
                    log_1.default.info('Mouse disabled.');
                }
                break;
            }
            case actions_1.Kind.DragStart: {
                if (this.mouse_enabled) {
                    this.dragging = new screen_drag_1.default(this);
                    this.emit('input', this.dragging.start(action.event));
                    this.emit('drag-started');
                }
                else {
                    log_1.default.debug('Click ignored because mouse is disabled.');
                }
                break;
            }
            case actions_1.Kind.DragUpdate: {
                if (this.mouse_enabled && this.dragging !== null) {
                    var input = this.dragging.drag(action.event);
                    if (input) {
                        this.emit('input', input);
                        this.emit('drag-updated');
                    }
                }
                break;
            }
            case actions_1.Kind.DragEnd: {
                if (this.mouse_enabled && this.dragging !== null) {
                    this.emit('input', this.dragging.end(action.event));
                    this.emit('drag-ended');
                    this.dragging = null;
                }
                break;
            }
            case actions_1.Kind.WheelScroll: {
                if (this.mouse_enabled) {
                    var input = this.wheel_scrolling.handleEvent(action.event);
                    if (input) {
                        this.emit('input', input);
                        this.emit('wheel-scrolled');
                    }
                }
                break;
            }
            case actions_1.Kind.Bell: {
                this.emit(action.visual ? 'visual-bell' : 'beep');
                break;
            }
            case actions_1.Kind.SetTitle: {
                this.title = action.title;
                this.emit('title-changed');
                log_1.default.info('Title is set to ', this.title);
                break;
            }
            case actions_1.Kind.SetIcon: {
                this.icon_path = action.icon_path;
                this.emit('icon-changed');
                log_1.default.info('Icon is set to ', this.icon_path);
                break;
            }
            case actions_1.Kind.UpdateLineHeight: {
                if (this.line_height !== action.line_height) {
                    this.line_height = action.line_height;
                    this.emit('line-height-changed');
                    log_1.default.info('Line height is changed to ', this.line_height);
                }
                break;
            }
            case actions_1.Kind.DisableAltKey: {
                this.alt_key_disabled = action.disabled;
                this.emit('alt-key-disabled');
                log_1.default.info('Alt key disabled: ', action.disabled);
                break;
            }
            case actions_1.Kind.DisableMetaKey: {
                this.meta_key_disabled = action.disabled;
                this.emit('meta-key-disabled');
                log_1.default.info('Meta key disabled: ', action.disabled);
                break;
            }
            case actions_1.Kind.ChangeCursorDrawDelay: {
                this.cursor_draw_delay = action.delay;
                this.emit('cursor-draw-delay-changed');
                log_1.default.info("Drawing cursor is delayed by " + action.delay + "ms");
                break;
            }
            case actions_1.Kind.StartBlinkCursor: {
                var changed = this.blink_cursor === false;
                this.blink_cursor = true;
                if (changed) {
                    this.emit('blink-cursor-started');
                }
                break;
            }
            case actions_1.Kind.StopBlinkCursor: {
                var changed = this.blink_cursor === true;
                this.blink_cursor = false;
                if (changed) {
                    this.emit('blink-cursor-stopped');
                }
                break;
            }
            default: {
                log_1.default.warn('Unhandled action: ', action);
                break;
            }
        }
    };
    NeovimStore.prototype.resize = function (lines, cols) {
        if (this.size.lines === lines
            && this.size.cols === cols) {
            return false;
        }
        this.size.lines = lines;
        this.size.cols = cols;
        this.scroll_region = {
            top: 0,
            left: 0,
            right: cols - 1,
            bottom: lines - 1,
        };
        log_1.default.debug("Screen is resized: (" + lines + " lines, " + cols + " cols)");
        return true;
    };
    return NeovimStore;
}(events_1.EventEmitter));
exports.default = NeovimStore;

},{"../log":8,"./actions":10,"./screen-drag":14,"./screen-wheel":15,"events":1,"flux":3}]},{},[7]);
